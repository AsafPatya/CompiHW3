%{
    #include "hw3_output.hpp"
    #include "parser_utils.hpp"
    #include "types.hpp"
    extern int yylex();
    extern int yylineno;
    void yyerror(const char*);
%}

%nonassoc VOID
%nonassoc INT
%nonassoc BYTE
%nonassoc B
%nonassoc BOOL
%nonassoc TRUE
%nonassoc FALSE
%nonassoc RETURN
%nonassoc IF
%nonassoc WHILE
%nonassoc BREAK
%nonassoc CONTINUE
%nonassoc SC
%nonassoc COMMA
%nonassoc ID
%nonassoc AUTO
%nonassoc NUM
%nonassoc STRING

//priority1
%right ASSIGN

//priority2
%left OR

//priority3
%left AND

//priority4
%left EQUALITY

//priority5
%nonassoc RELATIONAL

//priority6
%left ADDITIVE

//priority7
%left MULTIPLICATIVE

//priority8
%right NOT

//priority9
%left LPAREN RPAREN LBRACE RBRACE

//priority10
%right ELSE

%%

Program: Funcs
    {};

Funcs: /*ε*/
    {};
Funcs: FuncDecl Funcs
    {};

FuncDecl: FuncSignature LBRACE Statements RBRACE PopScope
    {};
FuncSignature: RetType ID LPAREN Formals RPAREN
    { $$ = Parser::instance().deriveFuncSignature($1, $2, $4, yylineno); };

RetType: Type
    { $$ = $1; } ;
RetType: VOID
    { $$ = $1; };

Formals: /*ε*/
    { $$ = Parser::instance().deriveFormals(); };
Formals: FormalsList
    { $$ = Parser::instance().deriveFormals($1); };

FormalsList: FormalDecl
    { $$ = Parser::instance().deriveFormalsList($1); };
FormalsList:    FormalDecl COMMA FormalsList
    { $$ = Parser::instance().deriveFormalsList($1, $3); };

FormalDecl: Type ID
    { $$ = Parser::instance().deriveFormalDecl($1, $2, yylineno); };

Statements: Statement
    {};
Statements: Statements Statement
    {};
Statement: PushScope LBRACE Statements RBRACE PopScope
    {};
Statement: Type ID SC
    { Parser::instance().deriveStatement($1, $2, yylineno); };
Statement: Type ID ASSIGN Exp SC
    { Parser::instance().deriveDeclaration($1, $2, $4, yylineno); };
Statement: AUTO ID ASSIGN Exp SC
    { Parser::instance().deriveDeclaration(nullptr, $2, $4, yylineno); };
Statement: ID ASSIGN Exp SC
    { Parser::instance().deriveAssignment($1, $3, yylineno); };
Statement: Call SC
    {};
Statement: RETURN SC
    { Parser::instance().deriveReturnVoid(yylineno); };
Statement: RETURN Exp SC
    { Parser::instance().deriveReturnExp($2, yylineno); };
Statement: IF LPAREN Exp IsBool RPAREN PushScope Statement PopScope
    {};
Statement: IF LPAREN Exp IsBool RPAREN PushScope Statement PopScope ELSE PushScope Statement PopScope
    {};
Statement: WHILE LPAREN Exp IsBool RPAREN PushWhileScope Statement PopScope
    {};
Statement: BREAK SC
    { Parser::instance().deriveBreak(yylineno); };
Statement: CONTINUE SC
     { Parser::instance().deriveContinue(yylineno); };

Call:    ID LPAREN ExpList RPAREN
    { $$ = Parser::instance().deriveCall(yylineno, $1, $3); };
Call:    ID LPAREN RPAREN
    { $$ = Parser::instance().deriveCall(yylineno, $1); };

ExpList:    Exp
    { $$ = Parser::instance().deriveExpList($1); };
ExpList:    Exp COMMA ExpList
    { $$ = Parser::instance().deriveExpList($1, $3); };

Type: INT
    { $$ = $1; };
Type: BYTE
    { $$ = $1; };
Type: BOOL
     { $$ = $1; };

Exp: LPAREN Exp RPAREN
    { $$ = $2; };
Exp: Exp MULTIPLICATIVE Exp
    { $$ = Parser::instance().deriveBinop($1, $3, yylineno); };
Exp: Exp ADDITIVE Exp
    { $$ = Parser::instance().deriveBinop($1, $3, yylineno); };
Exp: ID
    { $$ = Parser::instance().deriveId($1, yylineno); };
Exp: Call
    { $$ = $1; };
Exp: NUM
    { $$ = $1; };
Exp: NUM B
    { $$ = Parser::instance().deriveNumB($1, yylineno); };
Exp: STRING
    { $$ = $1; };
Exp: TRUE
    { $$ = $1; };
Exp: FALSE
    { $$ = $1; };
Exp: NOT Exp
    { $$ = Parser::instance().deriveNot($2, yylineno); };
Exp: Exp AND Exp
    { $$ = Parser::instance().deriveAndOr($1, $3, yylineno); };
Exp: Exp OR Exp
    { $$ = Parser::instance().deriveAndOr($1, $3, yylineno); };
Exp: Exp EQUALITY Exp
    { $$ = Parser::instance().deriveRelop($1, $3, yylineno); };
Exp: Exp RELATIONAL Exp
    { $$ = Parser::instance().deriveRelop($1, $3, yylineno); };
Exp: LPAREN Type RPAREN Exp
    { $$ = Parser::instance().deriveCast($2, $4, yylineno); };

PushScope: /*ε*/
    { Parser::instance().pushScope(); };

PushWhileScope  :    /*ε*/
    { Parser::instance().pushScope(true); };

PopScope   :    /*ε*/
    { Parser::instance().popScope(); };

IsBool     :    /*ε*/
    { Parser::instance().deriveBool($0, yylineno); };

%%

int main() {
	int parseValue = yyparse();
    Parser::instance().deriveProgram();
	return parseValue;
}

void yyerror(const char* message) {
	output::errorSyn(yylineno);
	exit(0);
}
